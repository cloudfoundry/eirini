// Code generated by counterfeiter. DO NOT EDIT.
package routefakes

import (
	"sync"

	v1a "k8s.io/api/apps/v1"
	v1c "k8s.io/api/autoscaling/v1"
	v1b "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
	v1 "k8s.io/client-go/kubernetes/typed/apps/v1"
)

type FakeStatefulSetInterface struct {
	CreateStub        func(*v1a.StatefulSet) (*v1a.StatefulSet, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *v1a.StatefulSet
	}
	createReturns struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	DeleteStub        func(string, *v1b.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 string
		arg2 *v1b.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCollectionStub        func(*v1b.DeleteOptions, v1b.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		arg1 *v1b.DeleteOptions
		arg2 v1b.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(string, v1b.GetOptions) (*v1a.StatefulSet, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 string
		arg2 v1b.GetOptions
	}
	getReturns struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	GetScaleStub        func(string, v1b.GetOptions) (*v1c.Scale, error)
	getScaleMutex       sync.RWMutex
	getScaleArgsForCall []struct {
		arg1 string
		arg2 v1b.GetOptions
	}
	getScaleReturns struct {
		result1 *v1c.Scale
		result2 error
	}
	getScaleReturnsOnCall map[int]struct {
		result1 *v1c.Scale
		result2 error
	}
	ListStub        func(v1b.ListOptions) (*v1a.StatefulSetList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		arg1 v1b.ListOptions
	}
	listReturns struct {
		result1 *v1a.StatefulSetList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 *v1a.StatefulSetList
		result2 error
	}
	PatchStub        func(string, types.PatchType, []byte, ...string) (*v1a.StatefulSet, error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		arg1 string
		arg2 types.PatchType
		arg3 []byte
		arg4 []string
	}
	patchReturns struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	UpdateStub        func(*v1a.StatefulSet) (*v1a.StatefulSet, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *v1a.StatefulSet
	}
	updateReturns struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	UpdateScaleStub        func(string, *v1c.Scale) (*v1c.Scale, error)
	updateScaleMutex       sync.RWMutex
	updateScaleArgsForCall []struct {
		arg1 string
		arg2 *v1c.Scale
	}
	updateScaleReturns struct {
		result1 *v1c.Scale
		result2 error
	}
	updateScaleReturnsOnCall map[int]struct {
		result1 *v1c.Scale
		result2 error
	}
	UpdateStatusStub        func(*v1a.StatefulSet) (*v1a.StatefulSet, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 *v1a.StatefulSet
	}
	updateStatusReturns struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	updateStatusReturnsOnCall map[int]struct {
		result1 *v1a.StatefulSet
		result2 error
	}
	WatchStub        func(v1b.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		arg1 v1b.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStatefulSetInterface) Create(arg1 *v1a.StatefulSet) (*v1a.StatefulSet, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *v1a.StatefulSet
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeStatefulSetInterface) CreateCalls(stub func(*v1a.StatefulSet) (*v1a.StatefulSet, error)) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeStatefulSetInterface) CreateArgsForCall(i int) *v1a.StatefulSet {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	argsForCall := fake.createArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatefulSetInterface) CreateReturns(result1 *v1a.StatefulSet, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) CreateReturnsOnCall(i int, result1 *v1a.StatefulSet, result2 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *v1a.StatefulSet
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) Delete(arg1 string, arg2 *v1b.DeleteOptions) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 string
		arg2 *v1b.DeleteOptions
	}{arg1, arg2})
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteReturns
	return fakeReturns.result1
}

func (fake *FakeStatefulSetInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeStatefulSetInterface) DeleteCalls(stub func(string, *v1b.DeleteOptions) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeStatefulSetInterface) DeleteArgsForCall(i int) (string, *v1b.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStatefulSetInterface) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatefulSetInterface) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatefulSetInterface) DeleteCollection(arg1 *v1b.DeleteOptions, arg2 v1b.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		arg1 *v1b.DeleteOptions
		arg2 v1b.ListOptions
	}{arg1, arg2})
	fake.recordInvocation("DeleteCollection", []interface{}{arg1, arg2})
	fake.deleteCollectionMutex.Unlock()
	if fake.DeleteCollectionStub != nil {
		return fake.DeleteCollectionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteCollectionReturns
	return fakeReturns.result1
}

func (fake *FakeStatefulSetInterface) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeStatefulSetInterface) DeleteCollectionCalls(stub func(*v1b.DeleteOptions, v1b.ListOptions) error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = stub
}

func (fake *FakeStatefulSetInterface) DeleteCollectionArgsForCall(i int) (*v1b.DeleteOptions, v1b.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	argsForCall := fake.deleteCollectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStatefulSetInterface) DeleteCollectionReturns(result1 error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatefulSetInterface) DeleteCollectionReturnsOnCall(i int, result1 error) {
	fake.deleteCollectionMutex.Lock()
	defer fake.deleteCollectionMutex.Unlock()
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStatefulSetInterface) Get(arg1 string, arg2 v1b.GetOptions) (*v1a.StatefulSet, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 string
		arg2 v1b.GetOptions
	}{arg1, arg2})
	fake.recordInvocation("Get", []interface{}{arg1, arg2})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeStatefulSetInterface) GetCalls(stub func(string, v1b.GetOptions) (*v1a.StatefulSet, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeStatefulSetInterface) GetArgsForCall(i int) (string, v1b.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStatefulSetInterface) GetReturns(result1 *v1a.StatefulSet, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) GetReturnsOnCall(i int, result1 *v1a.StatefulSet, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *v1a.StatefulSet
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) GetScale(arg1 string, arg2 v1b.GetOptions) (*v1c.Scale, error) {
	fake.getScaleMutex.Lock()
	ret, specificReturn := fake.getScaleReturnsOnCall[len(fake.getScaleArgsForCall)]
	fake.getScaleArgsForCall = append(fake.getScaleArgsForCall, struct {
		arg1 string
		arg2 v1b.GetOptions
	}{arg1, arg2})
	fake.recordInvocation("GetScale", []interface{}{arg1, arg2})
	fake.getScaleMutex.Unlock()
	if fake.GetScaleStub != nil {
		return fake.GetScaleStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getScaleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) GetScaleCallCount() int {
	fake.getScaleMutex.RLock()
	defer fake.getScaleMutex.RUnlock()
	return len(fake.getScaleArgsForCall)
}

func (fake *FakeStatefulSetInterface) GetScaleCalls(stub func(string, v1b.GetOptions) (*v1c.Scale, error)) {
	fake.getScaleMutex.Lock()
	defer fake.getScaleMutex.Unlock()
	fake.GetScaleStub = stub
}

func (fake *FakeStatefulSetInterface) GetScaleArgsForCall(i int) (string, v1b.GetOptions) {
	fake.getScaleMutex.RLock()
	defer fake.getScaleMutex.RUnlock()
	argsForCall := fake.getScaleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStatefulSetInterface) GetScaleReturns(result1 *v1c.Scale, result2 error) {
	fake.getScaleMutex.Lock()
	defer fake.getScaleMutex.Unlock()
	fake.GetScaleStub = nil
	fake.getScaleReturns = struct {
		result1 *v1c.Scale
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) GetScaleReturnsOnCall(i int, result1 *v1c.Scale, result2 error) {
	fake.getScaleMutex.Lock()
	defer fake.getScaleMutex.Unlock()
	fake.GetScaleStub = nil
	if fake.getScaleReturnsOnCall == nil {
		fake.getScaleReturnsOnCall = make(map[int]struct {
			result1 *v1c.Scale
			result2 error
		})
	}
	fake.getScaleReturnsOnCall[i] = struct {
		result1 *v1c.Scale
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) List(arg1 v1b.ListOptions) (*v1a.StatefulSetList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		arg1 v1b.ListOptions
	}{arg1})
	fake.recordInvocation("List", []interface{}{arg1})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeStatefulSetInterface) ListCalls(stub func(v1b.ListOptions) (*v1a.StatefulSetList, error)) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = stub
}

func (fake *FakeStatefulSetInterface) ListArgsForCall(i int) v1b.ListOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	argsForCall := fake.listArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatefulSetInterface) ListReturns(result1 *v1a.StatefulSetList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1a.StatefulSetList
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) ListReturnsOnCall(i int, result1 *v1a.StatefulSetList, result2 error) {
	fake.listMutex.Lock()
	defer fake.listMutex.Unlock()
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 *v1a.StatefulSetList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 *v1a.StatefulSetList
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) Patch(arg1 string, arg2 types.PatchType, arg3 []byte, arg4 ...string) (*v1a.StatefulSet, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		arg1 string
		arg2 types.PatchType
		arg3 []byte
		arg4 []string
	}{arg1, arg2, arg3Copy, arg4})
	fake.recordInvocation("Patch", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.patchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeStatefulSetInterface) PatchCalls(stub func(string, types.PatchType, []byte, ...string) (*v1a.StatefulSet, error)) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = stub
}

func (fake *FakeStatefulSetInterface) PatchArgsForCall(i int) (string, types.PatchType, []byte, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	argsForCall := fake.patchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStatefulSetInterface) PatchReturns(result1 *v1a.StatefulSet, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) PatchReturnsOnCall(i int, result1 *v1a.StatefulSet, result2 error) {
	fake.patchMutex.Lock()
	defer fake.patchMutex.Unlock()
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1a.StatefulSet
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) Update(arg1 *v1a.StatefulSet) (*v1a.StatefulSet, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *v1a.StatefulSet
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeStatefulSetInterface) UpdateCalls(stub func(*v1a.StatefulSet) (*v1a.StatefulSet, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeStatefulSetInterface) UpdateArgsForCall(i int) *v1a.StatefulSet {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatefulSetInterface) UpdateReturns(result1 *v1a.StatefulSet, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) UpdateReturnsOnCall(i int, result1 *v1a.StatefulSet, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *v1a.StatefulSet
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) UpdateScale(arg1 string, arg2 *v1c.Scale) (*v1c.Scale, error) {
	fake.updateScaleMutex.Lock()
	ret, specificReturn := fake.updateScaleReturnsOnCall[len(fake.updateScaleArgsForCall)]
	fake.updateScaleArgsForCall = append(fake.updateScaleArgsForCall, struct {
		arg1 string
		arg2 *v1c.Scale
	}{arg1, arg2})
	fake.recordInvocation("UpdateScale", []interface{}{arg1, arg2})
	fake.updateScaleMutex.Unlock()
	if fake.UpdateScaleStub != nil {
		return fake.UpdateScaleStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateScaleReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) UpdateScaleCallCount() int {
	fake.updateScaleMutex.RLock()
	defer fake.updateScaleMutex.RUnlock()
	return len(fake.updateScaleArgsForCall)
}

func (fake *FakeStatefulSetInterface) UpdateScaleCalls(stub func(string, *v1c.Scale) (*v1c.Scale, error)) {
	fake.updateScaleMutex.Lock()
	defer fake.updateScaleMutex.Unlock()
	fake.UpdateScaleStub = stub
}

func (fake *FakeStatefulSetInterface) UpdateScaleArgsForCall(i int) (string, *v1c.Scale) {
	fake.updateScaleMutex.RLock()
	defer fake.updateScaleMutex.RUnlock()
	argsForCall := fake.updateScaleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStatefulSetInterface) UpdateScaleReturns(result1 *v1c.Scale, result2 error) {
	fake.updateScaleMutex.Lock()
	defer fake.updateScaleMutex.Unlock()
	fake.UpdateScaleStub = nil
	fake.updateScaleReturns = struct {
		result1 *v1c.Scale
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) UpdateScaleReturnsOnCall(i int, result1 *v1c.Scale, result2 error) {
	fake.updateScaleMutex.Lock()
	defer fake.updateScaleMutex.Unlock()
	fake.UpdateScaleStub = nil
	if fake.updateScaleReturnsOnCall == nil {
		fake.updateScaleReturnsOnCall = make(map[int]struct {
			result1 *v1c.Scale
			result2 error
		})
	}
	fake.updateScaleReturnsOnCall[i] = struct {
		result1 *v1c.Scale
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) UpdateStatus(arg1 *v1a.StatefulSet) (*v1a.StatefulSet, error) {
	fake.updateStatusMutex.Lock()
	ret, specificReturn := fake.updateStatusReturnsOnCall[len(fake.updateStatusArgsForCall)]
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 *v1a.StatefulSet
	}{arg1})
	fake.recordInvocation("UpdateStatus", []interface{}{arg1})
	fake.updateStatusMutex.Unlock()
	if fake.UpdateStatusStub != nil {
		return fake.UpdateStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateStatusReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *FakeStatefulSetInterface) UpdateStatusCalls(stub func(*v1a.StatefulSet) (*v1a.StatefulSet, error)) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = stub
}

func (fake *FakeStatefulSetInterface) UpdateStatusArgsForCall(i int) *v1a.StatefulSet {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	argsForCall := fake.updateStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatefulSetInterface) UpdateStatusReturns(result1 *v1a.StatefulSet, result2 error) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) UpdateStatusReturnsOnCall(i int, result1 *v1a.StatefulSet, result2 error) {
	fake.updateStatusMutex.Lock()
	defer fake.updateStatusMutex.Unlock()
	fake.UpdateStatusStub = nil
	if fake.updateStatusReturnsOnCall == nil {
		fake.updateStatusReturnsOnCall = make(map[int]struct {
			result1 *v1a.StatefulSet
			result2 error
		})
	}
	fake.updateStatusReturnsOnCall[i] = struct {
		result1 *v1a.StatefulSet
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) Watch(arg1 v1b.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		arg1 v1b.ListOptions
	}{arg1})
	fake.recordInvocation("Watch", []interface{}{arg1})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.watchReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStatefulSetInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeStatefulSetInterface) WatchCalls(stub func(v1b.ListOptions) (watch.Interface, error)) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *FakeStatefulSetInterface) WatchArgsForCall(i int) v1b.ListOptions {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	argsForCall := fake.watchArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStatefulSetInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeStatefulSetInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.getScaleMutex.RLock()
	defer fake.getScaleMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateScaleMutex.RLock()
	defer fake.updateScaleMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStatefulSetInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v1.StatefulSetInterface = new(FakeStatefulSetInterface)
